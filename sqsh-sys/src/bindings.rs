/* automatically generated by rust-bindgen 0.72.1 */

use libc::{mode_t, time_t, FILE};

#[doc = " typedef used for indexing"]
pub type sqsh_index_t = usize;
pub type sqsh_file_iterator_mt_cb = ::core::option::Option<
    unsafe extern "C" fn(
        file: *const SqshFile,
        iterator: *const SqshFileIterator,
        offset: u64,
        data: *mut ::core::ffi::c_void,
        err: ::core::ffi::c_int,
    ),
>;
pub type sqsh_file_to_stream_mt_cb = ::core::option::Option<
    unsafe extern "C" fn(
        file: *const SqshFile,
        stream: *mut FILE,
        data: *mut ::core::ffi::c_void,
        err: ::core::ffi::c_int,
    ),
>;
#[repr(transparent)]
#[doc = " The compression used in the archive."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshSuperblockCompressionId(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " The flags used in the superblock."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshSuperblockFlags(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " definitions of gzip strategies"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshGzipStrategies(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " definitions xz filters"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshXzFilters(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " definitions of lz4 flags"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshLz4Flags(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " definitions of Lzo algorithms"]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshLzoAlgorithm(pub ::core::ffi::c_uint);
#[repr(transparent)]
#[doc = " The type of an external attribute."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshXattrType(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshInodeMap {
    _unused: [u8; 0],
}
#[doc = " table/id_table.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshIdTable {
    _unused: [u8; 0],
}
#[doc = " table/export_table.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshExportTable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshXattrTable {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshFragmentTable {
    _unused: [u8; 0],
}
#[doc = " archive/trailing_context.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshTrailingContext {
    _unused: [u8; 0],
}
#[doc = " archive/superblock_context.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshSuperblock {
    _unused: [u8; 0],
}
#[doc = " The SqshConfig struct contains all the configuration options for\n a sqsh session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshConfig {
    #[doc = " represents the offset in bytes where the sqsh_archive\n will start."]
    pub archive_offset: u64,
    #[doc = " represents the addressable size of the source in bytes.\n\n Please note that this is not the size of the archive, but the size of the\n source. So that the maximal size of the archive is `source_size -\n archive_offset`.\n\n This field is only used when the source_mapper is unable to determine the\n size of the source itself. This is the case for the following mappers:\n\n - `sqsh_mapper_impl_static`"]
    pub source_size: u64,
    #[doc = " source_mapper is the memory mapper implementation that will be\n used to map the archive.\n\n - `sqsh_mapper_impl_mmap`: the archive will be loaded from a file. The\n    source will be interpreted as a file path. this is the default.\n - `sqsh_mapper_impl_static`: the archive will be interpreted from a\n    static buffer.\n - `sqsh_mapper_impl_curl`: the archive will be loaded from a remote\n   location. The source will be interpreted as a URL."]
    pub source_mapper: *const SqshMemoryMapperImpl,
    #[doc = " the block size used to retrieve chunks of data from the mapper.\n If unset or 0, the block size will be determined by the mapper."]
    pub mapper_block_size: ::core::ffi::c_int,
    #[doc = " the size of the LRU cache used to cache chunks of data from the\n mapper. If unset or 0, the LRU defaults to 32. if set to -1, the LRU\n will be disabled."]
    pub mapper_lru_size: ::core::ffi::c_int,
    pub compression_lru_size: ::core::ffi::c_int,
    #[doc = " the maximum depth of symlinks that will be followed. If unset or\n 0, the max symlink depth will be 100."]
    pub max_symlink_depth: usize,
    #[doc = " the size of the LRU cache used to cache chunks of data from the\n data blocks. If unset or 0, the LRU defaults to 128. if set to -1, the\n LRU will be disabled."]
    pub data_lru_size: ::core::ffi::c_int,
    #[doc = " the size of the LRU cache used to cache chunks of data from the\n metablocks. If unset or 0, the LRU defaults to 128. if set to -1, the LRU\n will be disabled."]
    pub metablock_lru_size: ::core::ffi::c_int,
    #[doc = "<div class=\"warning\">PRIVATE</div>"]
    pub _reserved: [::core::ffi::c_char; 128usize],
}
#[doc = " The Sqsh struct contains all information about the current\n sqsh session."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshArchive {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshMapManager {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshCompressionOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshFile {
    _unused: [u8; 0],
}
#[doc = " The file reader allows to read user defined byte ranges from a file\n inside of a SqshArchive."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshFileReader {
    _unused: [u8; 0],
}
#[doc = " file/file_iterator.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshFileIterator {
    _unused: [u8; 0],
}
#[repr(transparent)]
#[doc = " enum that represents the file type."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshFileType(pub ::core::ffi::c_uint);
#[doc = " iterator/directory_iterator.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshDirectoryIterator {
    _unused: [u8; 0],
}
#[repr(transparent)]
#[doc = " Error codes for sqsh."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshError(pub ::core::ffi::c_uint);
#[doc = " mapper/mapper.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshMapper {
    _unused: [u8; 0],
}
#[doc = " The implementation of a memory mapper."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshMemoryMapperImpl {
    #[doc = " A hint to libsqsh to use this block size if the user did not\n specify one."]
    pub block_size_hint: usize,
    pub init: ::core::option::Option<
        unsafe extern "C" fn(
            mapper: *mut SqshMapper,
            input: *const ::core::ffi::c_void,
            size: *mut usize,
        ) -> ::core::ffi::c_int,
    >,
    pub map: ::core::option::Option<
        unsafe extern "C" fn(
            mapper: *const SqshMapper,
            offset: sqsh_index_t,
            size: usize,
            data: *mut *mut u8,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " The function that unmaps a block of data from memory."]
    pub unmap: ::core::option::Option<
        unsafe extern "C" fn(
            mapper: *const SqshMapper,
            data: *mut u8,
            size: usize,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " The cleanup function for the mapper."]
    pub cleanup:
        ::core::option::Option<unsafe extern "C" fn(mapper: *mut SqshMapper) -> ::core::ffi::c_int>,
    #[doc = " The initialization function for the mapper. Use\n sqsh_mapper_set_user_data() to set custom user data."]
    pub init2: ::core::option::Option<
        unsafe extern "C" fn(
            mapper: *mut SqshMapper,
            input: *const ::core::ffi::c_void,
            size: *mut u64,
        ) -> ::core::ffi::c_int,
    >,
    #[doc = " The function that maps a block of data into memory."]
    pub map2: ::core::option::Option<
        unsafe extern "C" fn(
            mapper: *const SqshMapper,
            offset: u64,
            size: usize,
            data: *mut *mut u8,
        ) -> ::core::ffi::c_int,
    >,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshThreadpool {
    _unused: [u8; 0],
}
#[doc = " table/table.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshTable {
    _unused: [u8; 0],
}
#[doc = " tree/path_resolver.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshPathResolver {
    _unused: [u8; 0],
}
#[doc = " tree/walker.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshTreeWalker {
    _unused: [u8; 0],
}
#[repr(transparent)]
#[doc = " The state of the tree traversal."]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct SqshTreeTraversalState(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshTreeTraversal {
    _unused: [u8; 0],
}
#[doc = " xattr/xattr_iterator.c"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SqshXattrIterator {
    _unused: [u8; 0],
}
pub const SQSH_INODE_NO_FRAGMENT: u32 = 4294967295;
pub const SQSH_INODE_NO_XATTR: u32 = 4294967295;
pub const SQSH_VERSION: &::core::ffi::CStr = c"1.5.2";
pub const SQSH_VERSION_MAJOR: u32 = 1;
pub const SQSH_VERSION_MINOR: u32 = 5;
pub const SQSH_VERSION_PATCH: u32 = 2;
pub const SQSH_FILE_TYPE_UNKNOWN: ::core::ffi::c_int = -1;
impl SqshSuperblockCompressionId {
    pub const SQSH_COMPRESSION_GZIP: SqshSuperblockCompressionId = SqshSuperblockCompressionId(1);
    pub const SQSH_COMPRESSION_LZMA: SqshSuperblockCompressionId = SqshSuperblockCompressionId(2);
    pub const SQSH_COMPRESSION_LZO: SqshSuperblockCompressionId = SqshSuperblockCompressionId(3);
    pub const SQSH_COMPRESSION_XZ: SqshSuperblockCompressionId = SqshSuperblockCompressionId(4);
    pub const SQSH_COMPRESSION_LZ4: SqshSuperblockCompressionId = SqshSuperblockCompressionId(5);
    pub const SQSH_COMPRESSION_ZSTD: SqshSuperblockCompressionId = SqshSuperblockCompressionId(6);
}
impl SqshSuperblockFlags {
    pub const SQSH_SUPERBLOCK_UNCOMPRESSED_INODES: SqshSuperblockFlags = SqshSuperblockFlags(1);
    pub const SQSH_SUPERBLOCK_UNCOMPRESSED_DATA: SqshSuperblockFlags = SqshSuperblockFlags(2);
    pub const SQSH_SUPERBLOCK_CHECK: SqshSuperblockFlags = SqshSuperblockFlags(4);
    pub const SQSH_SUPERBLOCK_UNCOMPRESSED_FRAGMENTS: SqshSuperblockFlags = SqshSuperblockFlags(8);
    pub const SQSH_SUPERBLOCK_NO_FRAGMENTS: SqshSuperblockFlags = SqshSuperblockFlags(16);
    pub const SQSH_SUPERBLOCK_ALWAYS_FRAGMENTS: SqshSuperblockFlags = SqshSuperblockFlags(32);
    pub const SQSH_SUPERBLOCK_DUPLICATES: SqshSuperblockFlags = SqshSuperblockFlags(64);
    pub const SQSH_SUPERBLOCK_EXPORTABLE: SqshSuperblockFlags = SqshSuperblockFlags(128);
    pub const SQSH_SUPERBLOCK_UNCOMPRESSED_XATTRS: SqshSuperblockFlags = SqshSuperblockFlags(256);
    pub const SQSH_SUPERBLOCK_NO_XATTRS: SqshSuperblockFlags = SqshSuperblockFlags(512);
    pub const SQSH_SUPERBLOCK_COMPRESSOR_OPTIONS: SqshSuperblockFlags = SqshSuperblockFlags(1024);
    pub const SQSH_SUPERBLOCK_UNCOMPRESSED_IDS: SqshSuperblockFlags = SqshSuperblockFlags(2048);
}
impl SqshGzipStrategies {
    pub const SQSH_GZIP_STRATEGY_NONE: SqshGzipStrategies = SqshGzipStrategies(0);
    pub const SQSH_GZIP_STRATEGY_DEFAULT: SqshGzipStrategies = SqshGzipStrategies(1);
    pub const SQSH_GZIP_STRATEGY_FILTERED: SqshGzipStrategies = SqshGzipStrategies(2);
    pub const SQSH_GZIP_STRATEGY_HUFFMAN_ONLY: SqshGzipStrategies = SqshGzipStrategies(4);
    pub const SQSH_GZIP_STRATEGY_RLE: SqshGzipStrategies = SqshGzipStrategies(8);
    pub const SQSH_GZIP_STRATEGY_FIXED: SqshGzipStrategies = SqshGzipStrategies(16);
}
impl SqshXzFilters {
    pub const SQSH_XZ_FILTER_NONE: SqshXzFilters = SqshXzFilters(0);
    pub const SQSH_XZ_FILTER_X86: SqshXzFilters = SqshXzFilters(1);
    pub const SQSH_XZ_FILTER_POWERPC: SqshXzFilters = SqshXzFilters(2);
    pub const SQSH_XZ_FILTER_IA64: SqshXzFilters = SqshXzFilters(4);
    pub const SQSH_XZ_FILTER_ARM: SqshXzFilters = SqshXzFilters(8);
    pub const SQSH_XZ_FILTER_ARMTHUMB: SqshXzFilters = SqshXzFilters(16);
    pub const SQSH_XZ_FILTER_SPARC: SqshXzFilters = SqshXzFilters(32);
}
impl SqshLz4Flags {
    pub const SQS_LZ4_FLAG_NONE: SqshLz4Flags = SqshLz4Flags(0);
    pub const SQSH_LZ4_HIGH_COMPRESSION: SqshLz4Flags = SqshLz4Flags(1);
}
impl SqshLzoAlgorithm {
    pub const SQSH_LZO_ALGORITHM_LZO1X_1: SqshLzoAlgorithm = SqshLzoAlgorithm(0);
    pub const SQSH_LZO_ALGORITHM_LZO1X_1_11: SqshLzoAlgorithm = SqshLzoAlgorithm(1);
    pub const SQSH_LZO_ALGORITHM_LZO1X_1_12: SqshLzoAlgorithm = SqshLzoAlgorithm(2);
    pub const SQSH_LZO_ALGORITHM_LZO1X_1_15: SqshLzoAlgorithm = SqshLzoAlgorithm(3);
    pub const SQSH_LZO_ALGORITHM_LZO1X_999: SqshLzoAlgorithm = SqshLzoAlgorithm(4);
}
impl SqshXattrType {
    pub const SQSH_XATTR_USER: SqshXattrType = SqshXattrType(0);
    pub const SQSH_XATTR_TRUSTED: SqshXattrType = SqshXattrType(1);
    pub const SQSH_XATTR_SECURITY: SqshXattrType = SqshXattrType(2);
}
impl SqshFileType {
    pub const SQSH_FILE_TYPE_DIRECTORY: SqshFileType = SqshFileType(257);
    pub const SQSH_FILE_TYPE_FILE: SqshFileType = SqshFileType(258);
    pub const SQSH_FILE_TYPE_SYMLINK: SqshFileType = SqshFileType(259);
    pub const SQSH_FILE_TYPE_BLOCK: SqshFileType = SqshFileType(260);
    pub const SQSH_FILE_TYPE_CHAR: SqshFileType = SqshFileType(261);
    pub const SQSH_FILE_TYPE_FIFO: SqshFileType = SqshFileType(262);
    pub const SQSH_FILE_TYPE_SOCKET: SqshFileType = SqshFileType(263);
}
impl SqshError {
    pub const SQSH_SUCCESS: SqshError = SqshError(0);
    pub const SQSH_ERROR_SECTION_START: SqshError = SqshError(256);
    pub const SQSH_ERROR_SUPERBLOCK_TOO_SMALL: SqshError = SqshError(257);
    pub const SQSH_ERROR_WRONG_MAGIC: SqshError = SqshError(258);
    pub const SQSH_ERROR_BLOCKSIZE_MISMATCH: SqshError = SqshError(259);
    pub const SQSH_ERROR_SIZE_MISMATCH: SqshError = SqshError(260);
    pub const SQSH_ERROR_COMPRESSION_INIT: SqshError = SqshError(261);
    pub const SQSH_ERROR_COMPRESSION_UNSUPPORTED: SqshError = SqshError(262);
    pub const SQSH_ERROR_COMPRESSION_DECOMPRESS: SqshError = SqshError(263);
    pub const SQSH_ERROR_UNKNOWN_FILE_TYPE: SqshError = SqshError(264);
    #[deprecated]
    #[doc = " Since 1.1.0. Use SQSH_ERROR_UNKNOWN_FILE_TYPE instead."]
    pub const SQSH_ERROR_UNKOWN_FILE_TYPE: SqshError = SqshError(264);
    pub const SQSH_ERROR_NOT_A_DIRECTORY: SqshError = SqshError(265);
    pub const SQSH_ERROR_NOT_A_FILE: SqshError = SqshError(266);
    pub const SQSH_ERROR_MALLOC_FAILED: SqshError = SqshError(267);
    pub const SQSH_ERROR_MUTEX_INIT_FAILED: SqshError = SqshError(268);
    pub const SQSH_ERROR_MUTEX_LOCK_FAILED: SqshError = SqshError(269);
    pub const SQSH_ERROR_MUTEX_DESTROY_FAILED: SqshError = SqshError(270);
    pub const SQSH_ERROR_OUT_OF_BOUNDS: SqshError = SqshError(271);
    pub const SQSH_ERROR_INTEGER_OVERFLOW: SqshError = SqshError(272);
    pub const SQSH_ERROR_NO_SUCH_FILE: SqshError = SqshError(273);
    pub const SQSH_ERROR_NO_SUCH_XATTR: SqshError = SqshError(274);
    pub const SQSH_ERROR_NO_FRAGMENT_TABLE: SqshError = SqshError(275);
    pub const SQSH_ERROR_NO_EXTENDED_DIRECTORY: SqshError = SqshError(276);
    pub const SQSH_ERROR_NO_EXPORT_TABLE: SqshError = SqshError(277);
    pub const SQSH_ERROR_NO_XATTR_TABLE: SqshError = SqshError(278);
    pub const SQSH_ERROR_NO_COMPRESSION_OPTIONS: SqshError = SqshError(279);
    pub const SQSH_ERROR_MAPPER_INIT: SqshError = SqshError(280);
    pub const SQSH_ERROR_MAPPER_MAP: SqshError = SqshError(281);
    pub const SQSH_ERROR_CURL_INVALID_RANGE_HEADER: SqshError = SqshError(282);
    pub const SQSL_ERROR_ELEMENT_NOT_FOUND: SqshError = SqshError(283);
    pub const SQSH_ERROR_INVALID_ARGUMENT: SqshError = SqshError(284);
    pub const SQSH_ERROR_WALKER_CANNOT_GO_UP: SqshError = SqshError(285);
    pub const SQSH_ERROR_WALKER_CANNOT_GO_DOWN: SqshError = SqshError(286);
    pub const SQSH_ERROR_CORRUPTED_INODE: SqshError = SqshError(287);
    pub const SQSH_ERROR_CORRUPTED_DIRECTORY_ENTRY: SqshError = SqshError(288);
    pub const SQSH_ERROR_INTERNAL: SqshError = SqshError(289);
    pub const SQSH_ERROR_INODE_MAP_IS_INCONSISTENT: SqshError = SqshError(290);
    pub const SQSH_ERROR_XATTR_SIZE_MISMATCH: SqshError = SqshError(291);
    pub const SQSH_ERROR_UNSUPPORTED_VERSION: SqshError = SqshError(292);
    pub const SQSH_ERROR_TOO_MANY_SYMLINKS_FOLLOWED: SqshError = SqshError(293);
    pub const SQSH_ERROR_CORRUPTED_DIRECTORY_HEADER: SqshError = SqshError(294);
    pub const SQSH_ERROR_COMPRESSION_FINISHED: SqshError = SqshError(295);
    pub const SQSH_ERROR_NO_SUCH_ELEMENT: SqshError = SqshError(296);
    pub const SQSH_ERROR_DIRECTORY_RECURSION: SqshError = SqshError(297);
    pub const SQSH_ERROR_INODE_PARENT_MISMATCH: SqshError = SqshError(298);
    pub const SQSH_ERROR_INODE_PARENT_UNSET: SqshError = SqshError(299);
    pub const SQSH_ERROR_NOT_A_SYMLINK: SqshError = SqshError(300);
}
impl SqshTreeTraversalState {
    #[doc = " The traversal is in the initial state, right after initialization."]
    pub const SQSH_TREE_TRAVERSAL_STATE_INIT: SqshTreeTraversalState = SqshTreeTraversalState(0);
    #[doc = " The traversal iterator is currently pointing at an object it will visit\n only once. This includes regular files, special files like named pipes,\n symlinks, or devices, and directories that will not be descended into\n because of a configured max depth."]
    pub const SQSH_TREE_TRAVERSAL_STATE_FILE: SqshTreeTraversalState = SqshTreeTraversalState(1);
    #[doc = " The traversal iterator is currently pointing at a directory object, right\n before SqshTreeTraversal is about to descend into it. The traversal\n iterator will eventually visit the same object with state\n SQSH_TREE_TRAVERSAL_STATE_DIRECTORY_END"]
    pub const SQSH_TREE_TRAVERSAL_STATE_DIRECTORY_BEGIN: SqshTreeTraversalState =
        SqshTreeTraversalState(2);
    #[doc = " The traversal iterator is currently pointing at a directory object, after\n SqshTreeTraversal has finished iterating over it."]
    pub const SQSH_TREE_TRAVERSAL_STATE_DIRECTORY_END: SqshTreeTraversalState =
        SqshTreeTraversalState(3);
}
unsafe extern "C" {
    #[doc = "\n Retrieves the size of the trailing data in a context.\n\n# Arguments\n- context The context to retrieve the size from.\n\n# Returns\n The size of the trailing data in the context."]
    pub fn sqsh_trailing_size(context: *const SqshTrailingContext) -> usize;
    #[doc = "\n Retrieves the trailing data in a context.\n\n# Arguments\n- context The context to retrieve the data from.\n\n# Returns\n The trailing data in the context."]
    pub fn sqsh_trailing_data(context: *const SqshTrailingContext) -> *const u8;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_inode_map_get2() instead.\n\n Gets the inode reference for a given inode number.\n\n# Arguments\n- map The context to use.\n- inode_number The inode number to get the reference for.\n\n# Returns\n The inode reference on success, 0 on error."]
    pub fn sqsh_inode_map_get(map: *const SqshInodeMap, inode_number: u64) -> u64;
    #[must_use]
    #[doc = "\n Gets the inode reference for a given inode number.\n\n# Arguments\n-  map           The context to use.\n-  inode_number  The inode number to get the reference for.\n- err           Pointer to an int where the error code will be\n stored.\n\n# Returns\n The inode reference on success, 0 on error."]
    pub fn sqsh_inode_map_get2(
        map: *const SqshInodeMap,
        inode_number: u32,
        err: *mut ::core::ffi::c_int,
    ) -> u64;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_inode_map_set2() instead.\n\n Sets the inode reference for a given inode number.\n\n# Arguments\n- map The context to use.\n- inode_number The inode number to set the reference for.\n- inode_ref The inode reference to set.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_inode_map_set(
        map: *mut SqshInodeMap,
        inode_number: u64,
        inode_ref: u64,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Sets the inode reference for a given inode number.\n\n# Arguments\n- map The context to use.\n- inode_number The inode number to set the reference for.\n- inode_ref The inode reference to set.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_inode_map_set2(
        map: *mut SqshInodeMap,
        inode_number: u32,
        inode_ref: u64,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Retrieves the compression id of a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the compression id\n from.\n\n# Returns\n The compression id of the superblock context."]
    pub fn sqsh_superblock_compression_id(
        context: *const SqshSuperblock,
    ) -> SqshSuperblockCompressionId;
    #[doc = "\n Retrieves the start offset of the directory table in a superblock\n context.\n\n# Arguments\n- context The superblock context to retrieve the directory table\n start offset from.\n\n# Returns\n The start offset of the directory table in the superblock context."]
    pub fn sqsh_superblock_directory_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the start offset of the fragment table in a superblock\n context.\n\n# Arguments\n- context The superblock context to retrieve the fragment table\n start offset from.\n\n# Returns\n The start offset of the fragment table in the superblock context."]
    pub fn sqsh_superblock_fragment_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the number of inodes in an archive.\n\n# Arguments\n- context The superblock context to retrieve the inode count from.\n\n# Returns\n The number of inodes in the superblock context."]
    pub fn sqsh_superblock_inode_count(context: *const SqshSuperblock) -> u32;
    #[doc = "\n Retrieves the major version of an archive.\n\n# Arguments\n- superblock The superblock context to retrieve the major version\n from.\n\n# Returns\n The major version of this archive."]
    pub fn sqsh_superblock_version_major(superblock: *const SqshSuperblock) -> u16;
    #[doc = "\n Retrieves the minor version of an archive.\n\n# Arguments\n- superblock The superblock context to retrieve the minor version\n from.\n\n# Returns\n The minor version of this archive."]
    pub fn sqsh_superblock_version_minor(superblock: *const SqshSuperblock) -> u16;
    #[doc = "\n Retrieves the start offset of the inode table in an archive.\n\n# Arguments\n- context The superblock context to retrieve the inode table start\n offset from.\n\n# Returns\n The start offset of the inode table in the superblock context."]
    pub fn sqsh_superblock_inode_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the start offset of the id table in an archive.\n\n# Arguments\n- context The superblock context to retrieve the id table start\n offset from.\n\n# Returns\n The start offset of the id table in the superblock context."]
    pub fn sqsh_superblock_id_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the number of ids in an archive.\n\n# Arguments\n- context The superblock context to retrieve the ids count from.\n\n# Returns\n The number of inodes in the superblock context."]
    pub fn sqsh_superblock_id_count(context: *const SqshSuperblock) -> u16;
    #[doc = "\n Retrieves the start offset of the export table in an archive.\n\n# Arguments\n- context The superblock context to retrieve the export table start\n offset from.\n\n# Returns\n The start offset of the export table in the superblock context."]
    pub fn sqsh_superblock_export_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the start offset of the xattr id table in an archive.\n\n# Arguments\n- context The superblock context to retrieve the xattr id table\n start offset from.\n\n# Returns\n The start offset of the xattr id table in the superblock context."]
    pub fn sqsh_superblock_xattr_id_table_start(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Retrieves the reference of the root inode in a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the root inode\n reference from.\n\n# Returns\n The reference of the root inode in the superblock context."]
    pub fn sqsh_superblock_inode_root_ref(context: *const SqshSuperblock) -> u64;
    #[doc = "\n Checks if a superblock context has fragment table.\n\n# Arguments\n- context The superblock context to check.\n\n# Returns\n True if the superblock context has a fragment table, false otherwise."]
    pub fn sqsh_superblock_has_fragments(context: *const SqshSuperblock) -> bool;
    #[doc = "\n Checks if a superblock context has an export table.\n\n# Arguments\n- context The superblock context to check.\n\n# Returns\n True if the superblock context has an export table, false otherwise."]
    pub fn sqsh_superblock_has_export_table(context: *const SqshSuperblock) -> bool;
    #[doc = "\n Checks if a superblock context has an xattr table.\n\n# Arguments\n- context The superblock context to check.\n\n# Returns\n True if the superblock context has an xattr table, false otherwise."]
    pub fn sqsh_superblock_has_xattr_table(context: *const SqshSuperblock) -> bool;
    #[doc = "\n Checks if a superblock context has compression options.\n\n# Arguments\n- context The superblock context to check.\n\n# Returns\n True if the superblock context has compression options, false\n otherwise."]
    pub fn sqsh_superblock_has_compression_options(context: *const SqshSuperblock) -> bool;
    #[doc = "\n Retrieves the block size of a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the block size from.\n\n# Returns\n The block size of the superblock context."]
    pub fn sqsh_superblock_block_size(context: *const SqshSuperblock) -> u32;
    #[doc = "\n Retrieves the modification time of a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the modification time\n from.\n\n# Returns\n The modification time of the superblock context."]
    pub fn sqsh_superblock_modification_time(context: *const SqshSuperblock) -> u32;
    #[doc = "\n Retrieves the number of fragment entries in a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the fragment entry\n count from.\n\n# Returns\n The number of fragment entries in the superblock context."]
    pub fn sqsh_superblock_fragment_entry_count(context: *const SqshSuperblock) -> u32;
    #[doc = "\n Retrieves the number of bytes used in a superblock context.\n\n# Arguments\n- context The superblock context to retrieve the bytes used from.\n\n# Returns\n The number of bytes used in the superblock context."]
    pub fn sqsh_superblock_bytes_used(context: *const SqshSuperblock) -> u64;
    #[must_use]
    #[doc = "\n initializes a archive context in heap.\n\n# Arguments\n- source the source to retrieve the archive from\n- config the configuration for the archive context.\n- err   Pointer to an int where the error code will be stored.\n\n# Returns\n a pointer to the archive context or NULL if an error occurred."]
    pub fn sqsh_archive_open(
        source: *const ::core::ffi::c_void,
        config: *const SqshConfig,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshArchive;
    #[doc = "\n sqsh_superblock returns the configuration object of the archive\n context.\n\n# Arguments\n- archive the SqshArchive structure.\n\n# Returns\n the superblock context."]
    pub fn sqsh_archive_config(archive: *const SqshArchive) -> *const SqshConfig;
    #[doc = "\n sqsh_superblock returns the superblock context.\n\n# Arguments\n- archive the Sqsh structure.\n\n# Returns\n the superblock context."]
    pub fn sqsh_archive_superblock(archive: *const SqshArchive) -> *const SqshSuperblock;
    #[doc = "\n sqsh_mapper returns the map manager to retrieve chunks of the archive\n file.\n\n# Arguments\n- archive the Sqsh structure.\n\n# Returns\n the mapper context."]
    pub fn sqsh_archive_map_manager(archive: *mut SqshArchive) -> *mut SqshMapManager;
    #[must_use]
    #[doc = "\n Retrieves the id table of a Sqsh instance.\n\n# Arguments\n-  archive    The Sqsh instance to retrieve the id table from.\n- id_table   Pointer to a struct SqshTable where the id table will\n be stored.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_id_table(
        archive: *mut SqshArchive,
        id_table: *mut *mut SqshIdTable,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Retrieves the export table of a Sqsh instance.\n\n# Arguments\n-  archive        The Sqsh instance to retrieve the inode cache\n                            from.\n- inode_map      Pointer to a struct SqshInodeMap where the\n                            inode cache will be stored.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_inode_map(
        archive: *mut SqshArchive,
        inode_map: *mut *mut SqshInodeMap,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Retrieves the export table of a Sqsh instance.\n\n# Arguments\n-  archive           The Sqsh instance to retrieve the export table\n                            from.\n- export_table   Pointer to a struct SqshTable where the export\n                            table will be stored.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_export_table(
        archive: *mut SqshArchive,
        export_table: *mut *mut SqshExportTable,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Retrieves the fragment table of a Sqsh instance.\n\n# Arguments\n-  archive          The Sqsh instance to retrieve the fragment table\n                              from.\n- fragment_table   Pointer to a struct SqshTable where the export\n                              table will be stored.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_fragment_table(
        archive: *mut SqshArchive,
        fragment_table: *mut *mut SqshFragmentTable,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Retrieves the xattr table of a Sqsh instance.\n\n# Arguments\n-  archive       The Sqsh instance to retrieve the xattr table\n                           from.\n- xattr_table   Pointer to a struct SqshTable where the export\n                           table will be stored.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_xattr_table(
        archive: *mut SqshArchive,
        xattr_table: *mut *mut SqshXattrTable,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Frees the resources used by a Sqsh instance.\n\n# Arguments\n- archive The Sqsh instance to free.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_archive_close(archive: *mut SqshArchive) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Initializes a SqshCompressionOptions struct.\n\n# Arguments\n- sqsh Sqsh context\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n The Initialized file context"]
    pub fn sqsh_compression_options_new(
        sqsh: *mut SqshArchive,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshCompressionOptions;
    #[doc = "\n returns the compression level of gzip\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression level of gzip"]
    pub fn sqsh_compression_options_gzip_compression_level(
        context: *const SqshCompressionOptions,
    ) -> u32;
    #[doc = "\n returns the compression window size of gzip\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression window size of gzip"]
    pub fn sqsh_compression_options_gzip_window_size(context: *const SqshCompressionOptions)
        -> u16;
    #[doc = "\n returns the compression strategy of gzip\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression strategy of gzip"]
    pub fn sqsh_compression_options_gzip_strategies(
        context: *const SqshCompressionOptions,
    ) -> SqshGzipStrategies;
    #[doc = "\n returns the dictionary size of xz\n\n# Arguments\n- context the compression options context\n\n# Returns\n the dictionary size of xz"]
    pub fn sqsh_compression_options_xz_dictionary_size(
        context: *const SqshCompressionOptions,
    ) -> u32;
    #[doc = "\n returns the compression options of xz\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression options of xz"]
    pub fn sqsh_compression_options_xz_filters(
        context: *const SqshCompressionOptions,
    ) -> SqshXzFilters;
    #[doc = "\n returns the version of lz4 used\n\n# Arguments\n- context the compression options context\n\n# Returns\n the version of lz4 used"]
    pub fn sqsh_compression_options_lz4_version(context: *const SqshCompressionOptions) -> u32;
    #[doc = "\n returns the flags of lz4\n\n# Arguments\n- context the compression options context\n\n# Returns\n the flags of lz4"]
    pub fn sqsh_compression_options_lz4_flags(context: *const SqshCompressionOptions) -> u32;
    #[doc = "\n returns the compression level of zstd\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression level of zstd"]
    pub fn sqsh_compression_options_zstd_compression_level(
        context: *const SqshCompressionOptions,
    ) -> u32;
    #[doc = "\n returns the algorithm of lzo\n\n# Arguments\n- context the compression options context\n\n# Returns\n the algorithm of lzo"]
    pub fn sqsh_compression_options_lzo_algorithm(
        context: *const SqshCompressionOptions,
    ) -> SqshLzoAlgorithm;
    #[doc = "\n returns the compression level of lzo\n\n# Arguments\n- context the compression options context\n\n# Returns\n the compression level of lzo"]
    pub fn sqsh_compression_options_lzo_compression_level(
        context: *const SqshCompressionOptions,
    ) -> u32;
    #[doc = "\n returns the size of the compression options struct\n\n# Arguments\n- context the compression options context\n\n# Returns\n the size of the compression options struct"]
    pub fn sqsh_compression_options_size(context: *const SqshCompressionOptions) -> usize;
    #[doc = "\n Frees a SqshCompressionOptions struct.\n\n# Arguments\n- context The file context to free.\n\n# Returns\n 0 on success, less than 0 on error"]
    pub fn sqsh_compression_options_free(
        context: *mut SqshCompressionOptions,
    ) -> ::core::ffi::c_int;
    #[doc = " Initializes a SqshFileReader struct.\n\n\n# Arguments\n- file The file context to retrieve the file contents from.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n a new file reader."]
    pub fn sqsh_file_reader_new(
        file: *const SqshFile,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFileReader;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_file_reader_advance2() instead.\n Advances the file reader by a certain amount of data and presents\n `size` bytes of data to the user.\n\n\n# Arguments\n- reader The file reader to skip data in.\n- offset The offset to skip.\n- size The size of the data to skip.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_reader_advance(
        reader: *mut SqshFileReader,
        offset: sqsh_index_t,
        size: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Advances the file reader by a certain amount of data and presents\n `size` bytes of data to the user.\n\n\n# Arguments\n- reader The file reader to skip data in.\n- offset The offset to skip.\n- size The size of the data to skip.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_reader_advance2(
        reader: *mut SqshFileReader,
        offset: u64,
        size: usize,
    ) -> ::core::ffi::c_int;
    #[doc = " Gets a pointer to the current data in the file reader.\n\n\n# Arguments\n- reader The file reader to get data from.\n\n# Returns\n A pointer to the current data in the file reader."]
    pub fn sqsh_file_reader_data(reader: *const SqshFileReader) -> *const u8;
    #[doc = " Gets the size of the current data in the file reader.\n\n\n# Arguments\n- reader The file reader to get data from.\n\n# Returns\n The size of the current data in the file reader."]
    pub fn sqsh_file_reader_size(reader: *const SqshFileReader) -> usize;
    #[doc = " Cleans up resources used by a SqshFileReader struct.\n\n\n# Arguments\n- reader The file reader struct to clean up.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_reader_free(reader: *mut SqshFileReader) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Creates a new SqshFileIterator struct and initializes it.\n\n\n# Arguments\n- file The file context to retrieve the file contents from.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n A pointer to the newly created and initialized SqshFileIterator\n struct."]
    pub fn sqsh_file_iterator_new(
        file: *const SqshFile,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFileIterator;
    #[must_use]
    #[doc = " Reads a certain amount of data from the file iterator.\n\n\n# Arguments\n- iterator The file iterator to read data from.\n- desired_size The desired size of the data to read. May be more or\n less than the actual size of the data read.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n- true  When the iterator was advanced\n- false When the iterator is at the end and no more entries are\n available or if an error occured."]
    pub fn sqsh_file_iterator_next(
        iterator: *mut SqshFileIterator,
        desired_size: usize,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[must_use]
    #[doc = " Checks if the current block is a zero block.\n\n\n# Arguments\n- iterator The file iterator to check.\n\n# Returns\n true if the current block is a zero block, false otherwise."]
    pub fn sqsh_file_iterator_is_zero_block(iterator: *const SqshFileIterator) -> bool;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_file_iterator_skip2() instead.\n\n Skips blocks until the block containing the offset is reached.\n Note that calling this function will invalidate the data pointer returned by\n sqsh_file_iterator_data().\n\n The offset is relative to the beginning of the current block or, if the\n iterator hasn't been forwarded with previous calls to\n sqsh_file_iterator_skip() or sqsh_file_iterator_next() the beginning of the\n first block.\n\n After calling this function `offset` is updated to the same position relative\n to the new block. See this visualisation:\n\n ```\n current_block: |<--- block 8000 --->|\n                           offset = 10000 --^\n -->  sqsh_file_iterator_skip(i, &offset, 1)\n current_block:                      |<--- block 8000 --->|\n                            offset = 2000 --^\n ```\n\n If libsqsh can map more than one block at once, it will do so until\n `desired_size` is reached. Note that `desired_size` is only a hint and\n libsqsh may return more or less data than requested.\n\n# Arguments\n- iterator      The file iterator to skip data in.\n- offset        The offset that is contained in the block to\n skip to.\n- desired_size      The desired size of the data to read.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_iterator_skip(
        iterator: *mut SqshFileIterator,
        offset: *mut sqsh_index_t,
        desired_size: usize,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Skips blocks until the block containing the offset is reached.\n Note that calling this function will invalidate the data pointer returned by\n sqsh_file_iterator_data().\n\n The offset is relative to the beginning of the current block or, if the\n iterator hasn't been forwarded with previous calls to\n sqsh_file_iterator_skip() or sqsh_file_iterator_next() the beginning of the\n first block.\n\n After calling this function `offset` is updated to the same position relative\n to the new block. See this visualisation:\n\n ```\n current_block: |<--- block 8000 --->|\n                           offset = 10000 --^\n -->  sqsh_file_iterator_skip(i, &offset, 1)\n current_block:                      |<--- block 8000 --->|\n                            offset = 2000 --^\n ```\n\n If libsqsh can map more than one block at once, it will do so until\n `desired_size` is reached. Note that `desired_size` is only a hint and\n libsqsh may return more or less data than requested.\n\n# Arguments\n- iterator      The file iterator to skip data in.\n- offset        The offset that is contained in the block to\n skip to.\n- desired_size      The desired size of the data to read.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_iterator_skip2(
        iterator: *mut SqshFileIterator,
        offset: *mut u64,
        desired_size: usize,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Gets a pointer to the current data in the file iterator.\n\n\n# Arguments\n- iterator The file iterator to get data from.\n\n# Returns\n A pointer to the current data in the file iterator."]
    pub fn sqsh_file_iterator_data(iterator: *const SqshFileIterator) -> *const u8;
    #[must_use]
    #[doc = " Returns the block size of the file iterator.\n\n\n# Arguments\n- iterator The file iterator to get the size from.\n\n# Returns\n The size of the data currently in the file iterator."]
    pub fn sqsh_file_iterator_block_size(iterator: *const SqshFileIterator) -> usize;
    #[must_use]
    #[doc = " Gets the size of the data currently in the file iterator.\n\n\n# Arguments\n- iterator The file iterator to get the size from.\n\n# Returns\n The size of the data currently in the file iterator."]
    pub fn sqsh_file_iterator_size(iterator: *const SqshFileIterator) -> usize;
    #[doc = " Frees the resources used by a SqshFileIterator struct.\n\n\n# Arguments\n- iterator The file iterator to free.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_file_iterator_free(iterator: *mut SqshFileIterator) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Initialize the file context from a path.\n\n# Arguments\n- archive The sqsh archive context.\n- path The path the file or directory.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_open(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[must_use]
    #[doc = "\n Initialize the file context from a path. This function is identical to\n `sqsh_open()` but if the path is a symlink, the symlink target not resolved.\n\n# Arguments\n- archive The sqsh archive context.\n- path The path the file or directory.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_lopen(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[must_use]
    #[doc = "\n Initializes a file context in heap\n\n# Arguments\n- archive The sqsh context to use.\n- inode_ref The inode reference to initialize the context with.\n- err Pointer to an int where the error code will be stored.\n\n# Returns\n a pointer to the sqsh context or NULL if an error occurred."]
    pub fn sqsh_open_by_ref(
        archive: *mut SqshArchive,
        inode_ref: u64,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[doc = "\n returns whether the file is an extended structure.\n\n# Arguments\n- context The file context.\n\n# Returns\n true if the file is an extended structure."]
    pub fn sqsh_file_is_extended(context: *const SqshFile) -> bool;
    #[doc = "\n Getter for the inode hard link count.\n\n# Arguments\n- context The file context.\n\n# Returns\n the amount of hard links to the inode."]
    pub fn sqsh_file_hard_link_count(context: *const SqshFile) -> u32;
    #[doc = "\n Getter for the file size. 0 if the file has no size.\n\n# Arguments\n- context The file context.\n\n# Returns\n the file type."]
    pub fn sqsh_file_size(context: *const SqshFile) -> u64;
    #[doc = "\n Getter for the permissions of the file.\n\n# Arguments\n- context The file context.\n\n# Returns\n the permissions of the file."]
    pub fn sqsh_file_permission(context: *const SqshFile) -> u16;
    #[doc = "\n Getter for the inode number.\n\n# Arguments\n- context The file context.\n\n# Returns\n the inode number."]
    pub fn sqsh_file_inode(context: *const SqshFile) -> u32;
    #[doc = "\n Getter for the file modification time in seconds since epoch.\n\n# Arguments\n- context The file context.\n\n# Returns\n the file modification time."]
    pub fn sqsh_file_modified_time(context: *const SqshFile) -> u32;
    #[doc = "\n Getter for the start block of the file content. This is only\n internally used and will be used while retrieving the file content.\n\n# Arguments\n- context The file context.\n\n# Returns\n the start block of the file content or UINT64_MAX if the type\n is not SQSH_FILE_TYPE_FILE."]
    pub fn sqsh_file_blocks_start(context: *const SqshFile) -> u64;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_file_blockcount2() instead.\n\n Getter for the amount of blocks of the file content. This is only\n internally used and will be used while retrieving the file content.\n\n# Arguments\n- context The file context.\n\n# Returns\n the amount of blocks of the file content. If the file is not of\n of type SQSH_FILE_TYPE_FILE, UINT32_MAX will be returned."]
    pub fn sqsh_file_block_count(context: *const SqshFile) -> u32;
    #[doc = "\n Getter for the amount of blocks of the file content. This is only\n internally used and will be used while retrieving the file content.\n\n# Arguments\n- context The file context.\n\n# Returns\n the amount of blocks of the file content. If the file is not of\n of type SQSH_FILE_TYPE_FILE, UINT32_MAX will be returned."]
    pub fn sqsh_file_block_count2(context: *const SqshFile) -> u64;
    #[doc = "\n Getter the size of a block of the file content. This is only\n internally used and will be used while retrieving the file content.\n\n# Arguments\n- context The file context.\n- index The index of the block.\n\n# Returns\n the size of the block with the index."]
    pub fn sqsh_file_block_size(context: *const SqshFile, index: u32) -> u32;
    #[doc = "\n Checks whether a certain block is compressed.\n\n# Arguments\n- context The file context.\n- index The index of the block.\n\n# Returns\n true if the block is compressed, false otherwise."]
    pub fn sqsh_file_block_is_compressed(context: *const SqshFile, index: u32) -> bool;
    #[doc = "\n retrieve the fragment block index. This is only internally used\n\n and will be used while retrieving the file content.\n# Arguments\n- context The file context.\n\n# Returns\n the fragment block index."]
    pub fn sqsh_file_fragment_block_index(context: *const SqshFile) -> u32;
    #[doc = "\n retrieve the fragment block offset. This is only internally used\n and will be used while retrieving the file content.\n\n# Arguments\n- context The file context.\n\n# Returns\n the offset inside of the fragment block."]
    pub fn sqsh_file_fragment_block_offset(context: *const SqshFile) -> u32;
    #[doc = "\n retrieve the directory block start. This is only internally used\n and will be used while iterating over the directory entries.\n\n# Arguments\n- context The file context.\n\n# Returns\n the directory block start."]
    pub fn sqsh_file_directory_block_start(context: *const SqshFile) -> u32;
    #[deprecated]
    #[doc = " Since 1.3.0. Use sqsh_file_directory_block_offset2() instead.\n\n retrieve the directory block offset. This is only internally used\n and will be used while iterating over the directory entries.\n\n# Arguments\n- context The file context.\n\n# Returns\n the directory block offset."]
    pub fn sqsh_file_directory_block_offset(context: *const SqshFile) -> u32;
    #[doc = "\n retrieve the directory block offset. This is only internally used\n and will be used while iterating over the directory entries.\n\n# Arguments\n- context The file context.\n\n# Returns\n the directory block offset."]
    pub fn sqsh_file_directory_block_offset2(context: *const SqshFile) -> u16;
    #[doc = "\n retrieve the parent inode of the directory.\n\n# Arguments\n- context The file context.\n\n# Returns\n the directory block offset."]
    pub fn sqsh_file_directory_parent_inode(context: *const SqshFile) -> u32;
    #[doc = "\n returns true if the file has a fragment block.\n\n# Arguments\n- context The file context.\n\n# Returns\n true if the file has a fragment block, false otherwise."]
    pub fn sqsh_file_has_fragment(context: *const SqshFile) -> bool;
    #[doc = "\n returns the type of the file.\n\n# Arguments\n- context The file context.\n\n# Returns\n the type of the file."]
    pub fn sqsh_file_type(context: *const SqshFile) -> SqshFileType;
    #[doc = "\n resolves the symlink target. After calling this function the file is\n in place changed to the target of the symlink.\n\n# Arguments\n- context The file context.\n\n# Returns\n int 0 on success, less than 0 on error."]
    pub fn sqsh_file_symlink_resolve(context: *mut SqshFile) -> ::core::ffi::c_int;
    #[doc = "\n resolves all symlink target targets until a file is hit. This function\n is similar to sqsh_file_symlink_resolve() but resolves symlinks recursively\n until a file is hit.\n\n# Arguments\n- context The file context.\n\n# Returns\n int 0 on success, less than 0 on error."]
    pub fn sqsh_file_symlink_resolve_all(context: *mut SqshFile) -> ::core::ffi::c_int;
    #[doc = "\n returns the target of a symbolic link. Be aware that the returned\n value is not zero terminated.\n\n To get the length of the target use sqsh_file_symlink_size().\n\n If you need a zero terminated string use sqsh_file_symlink_dup().\n\n# Arguments\n- context The file context.\n\n# Returns\n the target of a symbolic link, NULL if the file is not a symbolic\n link."]
    pub fn sqsh_file_symlink(context: *const SqshFile) -> *const ::core::ffi::c_char;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the target of a symbolic link.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n- context The file context.\n\n# Returns\n the target of a symbolic link, NULL if the file is not a symbolic\n link."]
    pub fn sqsh_file_symlink_dup(context: *const SqshFile) -> *mut ::core::ffi::c_char;
    #[doc = "\n returns the length of the target of a symbolic link in bytes.\n\n# Arguments\n- context The file context.\n\n# Returns\n the length of the target of a symbolic link in bytes or 0 if the\n file is not a symbolic link."]
    pub fn sqsh_file_symlink_size(context: *const SqshFile) -> u32;
    #[doc = "\n\n returns the device id of the device inode.\n\n# Arguments\n- context The file context.\n\n# Returns\n the device id of the device inode or 0 if the file is not a device."]
    pub fn sqsh_file_device_id(context: *const SqshFile) -> u32;
    #[doc = "\n returns the owner user id of the file.\n\n# Arguments\n- context The file context.\n\n# Returns\n the owner uid of the file."]
    pub fn sqsh_file_uid(context: *const SqshFile) -> u32;
    #[doc = "\n returns the owner group id of the file.\n\n# Arguments\n- context The file context.\n\n# Returns\n the owner gid of the file."]
    pub fn sqsh_file_gid(context: *const SqshFile) -> u32;
    #[doc = "\n returns the inode reference to this file.\n\n The owner reference is an encoded physical location of the inode inside of\n the archive.\n\n To decode this value use the following code:\n\n ```\n uint64_t ref = sqsh_file_ref(context);\n uint64_t outer_address = ref >> 16;\n uint64_t inner_address = ref & 0xffff;\n ```\n\n The outer address is the physical location of the metablock within the\n archive.\n\n The inner address is the physical location of the inode inside of the\n decompressed metablock.\n\n# Arguments\n- context The file context.\n\n# Returns\n the reference to this file."]
    pub fn sqsh_file_inode_ref(context: *const SqshFile) -> u64;
    #[doc = "\n returns index of the extended attribute inside of the xattr table.\n\n# Arguments\n- context The file context.\n\n# Returns\n the index of the extended attribute inside of the xattr table."]
    pub fn sqsh_file_xattr_index(context: *const SqshFile) -> u32;
    #[doc = "\n cleans up an file context and frees the memory.\n\n# Arguments\n- file The file context.\n\n# Returns\n int 0 on success, less than 0 on error."]
    pub fn sqsh_close(file: *mut SqshFile) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Allocates and initializes a new directory iterator.\n\n# Arguments\n-  file       file context of a directory to iterate over.\n- err        Pointer to an int where the error code will be stored.\n\n# Returns\n The new iterator on success, NULL on error."]
    pub fn sqsh_directory_iterator_new(
        file: *const SqshFile,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshDirectoryIterator;
    #[must_use]
    #[doc = "\n Advances the iterator to the next entry.\n\n# Arguments\n- iterator The iterator to advance.\n-    err      Pointer to an int where the error code will be\n stored.\n\n# Returns\n- true When the iterator has been advanced\n- false When the iterator has reached the end of the directory or if an\n error occured."]
    pub fn sqsh_directory_iterator_next(
        iterator: *mut SqshDirectoryIterator,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[must_use]
    #[doc = "\n Looks up an entry by name.\n\n# Arguments\n- iterator The iterator to use.\n-     name     The name of the entry to look up.\n-     name_len The length of the name.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_directory_iterator_lookup(
        iterator: *mut SqshDirectoryIterator,
        name: *const ::core::ffi::c_char,
        name_len: usize,
    ) -> ::core::ffi::c_int;
    #[deprecated]
    #[doc = " Since 1.3.0. Use sqsh_directory_iterator_name2() instead.\n\n Retrieves the size of the name of the current entry.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The size of the name on success, a negative value on error."]
    pub fn sqsh_directory_iterator_name_size(iterator: *const SqshDirectoryIterator) -> u16;
    #[doc = "\n Retrieves the inode number of the current entry.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The inode number."]
    pub fn sqsh_directory_iterator_inode(iterator: *const SqshDirectoryIterator) -> u32;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_directory_iterator_inode() instead.\n\n Retrieves the inode number of the current entry.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The inode number."]
    pub fn sqsh_directory_iterator_inode_number(iterator: *const SqshDirectoryIterator) -> u64;
    #[doc = "\n Retrieves the inode reference of the current entry.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The inode reference."]
    pub fn sqsh_directory_iterator_inode_ref(iterator: *const SqshDirectoryIterator) -> u64;
    #[doc = "\n Retrieves the inode type of the current entry.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The inode type on success, SQSH_INODE_TYPE_UNKNOWN on error."]
    pub fn sqsh_directory_iterator_file_type(
        iterator: *const SqshDirectoryIterator,
    ) -> SqshFileType;
    #[must_use]
    #[doc = "\n Loads the inode of the current entry.\n\n# Arguments\n-  iterator The iterator to use.\n- err  Pointer to an int where the error code will be stored.\n\n# Returns\n The loaded inode on success, NULL on error."]
    pub fn sqsh_directory_iterator_open_file(
        iterator: *const SqshDirectoryIterator,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[doc = "\n Retrieves the name of the current entry.\n\n The returned pointer is allocated internally and only valid until the next\n call of sqsh_directory_iterator_next(). It must not be freed. The returned\n string is not 0 terminated.\n\n# Arguments\n-  iterator  The iterator to use.\n- len       Pointer to a size_t where the length of the name will\n be stored.\n\n# Returns\n The name of the current entry."]
    pub fn sqsh_directory_iterator_name2(
        iterator: *const SqshDirectoryIterator,
        len: *mut usize,
    ) -> *const ::core::ffi::c_char;
    #[deprecated]
    #[doc = " Since 1.3.0. Use sqsh_directory_iterator_name2() instead.\n\n Retrieves the name of the current entry.\n\n The returned pointer is allocated internally and only valid until the next\n call of sqsh_directory_iterator_next(). It must not be freed. The returned\n string is not 0 terminated. Use sqsh_directory_iterator_name_size() to get\n the size of the value.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The name of the current entry."]
    pub fn sqsh_directory_iterator_name(
        iterator: *const SqshDirectoryIterator,
    ) -> *const ::core::ffi::c_char;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the name of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n-  iterator    The iterator to use.\n\n# Returns\n The name of the current entry."]
    pub fn sqsh_directory_iterator_name_dup(
        iterator: *const SqshDirectoryIterator,
    ) -> *mut ::core::ffi::c_char;
    #[doc = "\n Frees the resources used by a directory iterator.\n\n# Arguments\n- iterator The iterator to free.\n\n# Returns\n The file name of the current directory entry, NULL if the allocation\n fails. The user is responsible for freeing the memory."]
    pub fn sqsh_directory_iterator_free(iterator: *mut SqshDirectoryIterator)
        -> ::core::ffi::c_int;
    #[doc = " checks if a file exists.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n true if the file exists, false otherwise."]
    pub fn sqsh_easy_file_exists(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[doc = " retrieves the content of a file.\n\n The content is not null terminated. The size of the content can be retrieved\n with sqsh_file_size. The returned pointer needs to be released with `free()`.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The content of the file on success, NULL on error."]
    pub fn sqsh_easy_file_content(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut u8;
    #[doc = " retrieves the size of a file.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The size of the file on success, 0 on error."]
    pub fn sqsh_easy_file_size2(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> u64;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_easy_file_size2() instead.\n retrieves the size of a file.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The size of the file on success, 0 on error."]
    pub fn sqsh_easy_file_size(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> usize;
    #[doc = " retrieves unix permissions of a file.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The unix permissions of the file on success, 0 on error."]
    pub fn sqsh_easy_file_permission(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> mode_t;
    #[doc = " retrieves the modification time of a file.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The modification time of the file on success, 0 on error."]
    pub fn sqsh_easy_file_mtime2(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> u32;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_easy_file_mtime2() instead.\n retrieves the modification time of a file.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The modification time of the file on success, 0 on error."]
    pub fn sqsh_easy_file_mtime(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> time_t;
    #[doc = " retrieves the contents of a directory as a list of file names\n\n The returned list needs to be released with `free()`.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n A list of files and directories on success, NULL on error."]
    pub fn sqsh_easy_directory_list(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    #[doc = " retrieves the contents of a directory as a list of file paths\n\n The returned list needs to be released with `free()`.\n\n# Arguments\n- archive  The sqsh archive context.\n- path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n A list of files and directories on success, NULL on error."]
    pub fn sqsh_easy_directory_list_path(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    #[doc = " easy/traversal.c"]
    pub fn sqsh_easy_tree_traversal(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    #[doc = " retrieves all xattr keys of a file or directory.\n\n The returned list needs to be released with `free()`.\n\n# Arguments\n-  archive  The sqsh archive context.\n-  path     The path the file or directory.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n A list of xattr keys on success, NULL on error."]
    pub fn sqsh_easy_xattr_keys(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut *mut ::core::ffi::c_char;
    #[doc = " retrieves the value of a xattr key of a file or directory.\n\n The returned pointer needs to be released with `free()`.\n\n# Arguments\n-  archive  The sqsh archive context.\n-  path     The path the file or directory.\n-  key      The xattr key.\n- err     Pointer to an int where the error code will be stored.\n\n# Returns\n The value of the given xattr key on success, NULL on error."]
    pub fn sqsh_easy_xattr_get(
        archive: *mut SqshArchive,
        path: *const ::core::ffi::c_char,
        key: *const ::core::ffi::c_char,
        err: *mut ::core::ffi::c_int,
    ) -> *mut ::core::ffi::c_char;
    #[doc = " Print the error message for the given error code.\n\n# Arguments\n- error_code The error code.\n- msg The message to print before the error message."]
    pub fn sqsh_perror(error_code: ::core::ffi::c_int, msg: *const ::core::ffi::c_char);
    #[must_use]
    #[doc = " Get the error message for the given error code.\n\n This function is thread safe, but the returned string may be overwritten by\n the next call to this function on this thread.\n\n# Arguments\n- error_code The error code.\n# Returns\n The error message."]
    pub fn sqsh_error_str(error_code: ::core::ffi::c_int) -> *const ::core::ffi::c_char;
    #[doc = "\n Sets the user data for a mapper.\n\n# Arguments\n- mapper The mapper to set the user data for.\n- user_data The user data to set."]
    pub fn sqsh_mapper_set_user_data(mapper: *mut SqshMapper, user_data: *mut ::core::ffi::c_void);
    #[doc = "\n Retrieves the user data from a mapper.\n\n# Arguments\n- mapper The mapper to retrieve the user data from.\n\n# Returns\n The user data from the mapper."]
    pub fn sqsh_mapper_user_data(mapper: *const SqshMapper) -> *mut ::core::ffi::c_void;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_mapper_size2() instead.\n<div class=\"warning\">INTERNAL API</div>\n\n Retrieves the size of the input data in a mapper.\n\n# Arguments\n- mapper The mapper to retrieve the size from.\n\n# Returns\n The size of the input data in the mapper."]
    pub fn sqsh_mapper_size(mapper: *const SqshMapper) -> usize;
    #[doc = "<div class=\"warning\">INTERNAL API</div>\n\n Retrieves the size of the input data in a mapper.\n\n# Arguments\n- mapper The mapper to retrieve the size from.\n\n# Returns\n The size of the input data in the mapper."]
    pub fn sqsh_mapper_size2(mapper: *const SqshMapper) -> u64;
    #[doc = "<div class=\"warning\">INTERNAL API</div>\n\n Retrieves the block size for a mapper.\n\n# Arguments\n- mapper The mapper to retrieve the size from.\n\n# Returns\n The size of the input data in the mapper."]
    pub fn sqsh_mapper_block_size(mapper: *const SqshMapper) -> usize;
    #[doc = " a mapper that uses curl to download the file."]
    pub static sqsh_mapper_impl_curl: *const SqshMemoryMapperImpl;
    #[doc = " a mapper that uses mmap to map the file into memory."]
    pub static sqsh_mapper_impl_mmap: *const SqshMemoryMapperImpl;
    #[doc = " a mapper that uses a static buffer."]
    pub static sqsh_mapper_impl_static: *const SqshMemoryMapperImpl;
    #[doc = "\n writes data to a file descriptor.\n\n# Arguments\n- file The file context.\n- stream The descriptor to write the file contents to.\n\n# Returns\n The number of bytes read on success, less than 0 on error."]
    pub fn sqsh_file_to_stream(file: *const SqshFile, stream: *mut FILE) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n writes data to a file descriptor.\n\n# Arguments\n- file The file context.\n- threadpool The threadpool to use.\n- stream The descriptor to write the file contents to.\n- cb The callback to call when the operation is done.\n- data The data to pass to the callback."]
    pub fn sqsh_file_to_stream_mt(
        file: *const SqshFile,
        threadpool: *mut SqshThreadpool,
        stream: *mut FILE,
        cb: sqsh_file_to_stream_mt_cb,
        data: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = "\n creates a file descriptor from a file and calls a callback for each\n block.\n\n# Arguments\n- file The file context.\n- threadpool The threadpool to use.\n- cb The callback to call for each block.\n- data The data to pass to the callback."]
    pub fn sqsh_file_iterator_mt(
        file: *const SqshFile,
        threadpool: *mut SqshThreadpool,
        cb: sqsh_file_iterator_mt_cb,
        data: *mut ::core::ffi::c_void,
    );
    #[doc = "\n creates a new threadpool.\n\n# Arguments\n- threads The number of threads to use. Use 0 to use the number of\n available cores.\n- err The error code.\n# Returns\n The threadpool on success, NULL on error."]
    pub fn sqsh_threadpool_new(threads: usize, err: *mut ::core::ffi::c_int)
        -> *mut SqshThreadpool;
    pub fn sqsh_threadpool_wait(pool: *mut SqshThreadpool) -> ::core::ffi::c_int;
    #[doc = "\n cleans up a threadpool.\n\n# Arguments\n- pool The threadpool to uclean.\n# Returns\n The threadpool on success, NULL on error."]
    pub fn sqsh__threadpool_cleanup(pool: *mut SqshThreadpool) -> ::core::ffi::c_int;
    #[doc = "\n creates a new threadpool.\n\n# Arguments\n- pool The threadpool to free.\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_threadpool_free(pool: *mut SqshThreadpool) -> ::core::ffi::c_int;
    #[doc = "\n Retrieves an element from the table.\n\n# Arguments\n-  table The table to retrieve the element from.\n-  index The index of the element to retrieve.\n- target The buffer to store the element in.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_table_get(
        table: *const SqshTable,
        index: sqsh_index_t,
        target: *mut ::core::ffi::c_void,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Retrieves an element from the table.\n\n# Arguments\n-  table The table to retrieve the element from.\n-  index The index of the element to retrieve.\n- id The buffer to store the element in.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_id_table_get(
        table: *const SqshIdTable,
        index: sqsh_index_t,
        id: *mut u32,
    ) -> ::core::ffi::c_int;
    #[doc = "\n Retrieves an element from the table.\n\n# Arguments\n-  table The table to retrieve the element from.\n-  inode The index of the element to retrieve.\n- inode_ref A pointer to a uint64_t to store the inode reference\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_export_table_resolve_inode2(
        table: *const SqshExportTable,
        inode: u32,
        inode_ref: *mut u64,
    ) -> ::core::ffi::c_int;
    #[deprecated]
    #[doc = " Since 1.5.0. Use sqsh_export_table_resolve_inode2 instead.\n\n Retrieves an element from the table.\n\n# Arguments\n-  table The table to retrieve the element from.\n-  inode The index of the element to retrieve.\n- inode_ref A pointer to a uint64_t to store the inode reference\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_export_table_resolve_inode(
        table: *const SqshExportTable,
        inode: u64,
        inode_ref: *mut u64,
    ) -> ::core::ffi::c_int;
    #[doc = " Creates a new SqshPathResolver object at the root inode.\n\n\n# Arguments\n-   archive  The archive to use\n-  err      Pointer to an int where the error code will be stored.\n\n# Returns\n a new file reader."]
    pub fn sqsh_path_resolver_new(
        archive: *mut SqshArchive,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshPathResolver;
    #[must_use]
    #[doc = " Moves the walker one level up\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_up(walker: *mut SqshPathResolver) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Moves the walker to the next entry int the current directory.\n\n# Arguments\n-   walker  The walker to use\n-      err     Pointer to an int where the error code will be\n stored.\n\n# Returns\n- true if the walker was moved to the next entry.\n- false if the walker has no more entries to move to or an error\n occured."]
    pub fn sqsh_path_resolver_next(
        walker: *mut SqshPathResolver,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[doc = " Returns the inode type of the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the inode type of the current entry."]
    pub fn sqsh_path_resolver_type(walker: *const SqshPathResolver) -> SqshFileType;
    #[doc = " Returns the name of the current entry. This entry is not zero\n terminated.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_path_resolver_name(walker: *const SqshPathResolver) -> *const ::core::ffi::c_char;
    #[doc = "\n Returns the size of the name of the current entry.\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the size of the name of the current entry."]
    pub fn sqsh_path_resolver_name_size(walker: *const SqshPathResolver) -> u16;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the name of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_path_resolver_name_dup(walker: *const SqshPathResolver)
        -> *mut ::core::ffi::c_char;
    #[must_use]
    #[doc = " reverts the walker to the begining of the current directory.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_revert(walker: *mut SqshPathResolver) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Looks up an entry in the current directory.\n\n\n# Arguments\n-   walker  The walker to use\n-       name    The name of the entry to look up.\n-       name_size The size of the name.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_lookup(
        walker: *mut SqshPathResolver,
        name: *const ::core::ffi::c_char,
        name_size: usize,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Lets the walker enter the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_down(walker: *mut SqshPathResolver) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Moves the walker to the root directory.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_to_root(walker: *mut SqshPathResolver) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = " Returns the inode of the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n-      err     Pointer to an int where the error code will be\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_path_resolver_open_file(
        walker: *const SqshPathResolver,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[doc = " Returns the inode of the current working directory.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_path_resolver_dir_inode(walker: *const SqshPathResolver) -> u32;
    #[doc = " Returns the inode reference of the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the inode reference of the current item the resolver is pointing to."]
    pub fn sqsh_path_resolver_inode_ref(walker: *const SqshPathResolver) -> u64;
    #[must_use]
    #[doc = "\n Resolve a path with the tree walker.\n\n This function will resolve the given path with the tree walker. The base is\n the current directory.\n\n# Arguments\n-   walker           The walker to use\n-       path             The path to resolve.\n-       follow_symlinks  Whether to follow symlinks.\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_path_resolver_resolve(
        walker: *mut SqshPathResolver,
        path: *const ::core::ffi::c_char,
        follow_symlinks: bool,
    ) -> ::core::ffi::c_int;
    #[doc = " Cleans up resources used by a SqshPathResolver struct.\n\n\n# Arguments\n- reader The file reader struct to clean up.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_path_resolver_free(reader: *mut SqshPathResolver) -> ::core::ffi::c_int;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_new() instead.\n Creates a new SqshTreeWalker object at the root inode.\n\n\n# Arguments\n-   archive  The archive to use\n-  err      Pointer to an int where the error code will be stored.\n\n# Returns\n a new file reader."]
    pub fn sqsh_tree_walker_new(
        archive: *mut SqshArchive,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshTreeWalker;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_up() instead.\n Moves the walker one level up\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_up(walker: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_next() instead.\n\n Moves the walker to the next entry int the current directory.\n\n This function was deprecated to align the API with other iterator APIs. The\n `sqsh_tree_walker_next2()` uses the same signature as the other iterator.\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_next(walker: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_type() instead.\n Returns the inode type of the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the inode type of the current entry."]
    pub fn sqsh_tree_walker_type(walker: *const SqshTreeWalker) -> SqshFileType;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_name() instead.\n Returns the name of the current entry. This entry is not zero\n terminated.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_tree_walker_name(walker: *const SqshTreeWalker) -> *const ::core::ffi::c_char;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_name_size() instead.\n\n Returns the size of the name of the current entry.\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the size of the name of the current entry."]
    pub fn sqsh_tree_walker_name_size(walker: *const SqshTreeWalker) -> u16;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_name_dup() instead.\n\n creates a heap allocated copy of the name of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_tree_walker_name_dup(walker: *const SqshTreeWalker) -> *mut ::core::ffi::c_char;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_revert() instead.\n reverts the walker to the begining of the current directory.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_revert(walker: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_lookup() instead.\n Looks up an entry in the current directory.\n\n\n# Arguments\n-   walker  The walker to use\n-       name    The name of the entry to look up.\n-       name_size The size of the name.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_lookup(
        walker: *mut SqshTreeWalker,
        name: *const ::core::ffi::c_char,
        name_size: usize,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_down() instead.\n Lets the walker enter the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_down(walker: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_to_root() instead.\n Moves the walker to the root directory.\n\n\n# Arguments\n-   walker  The walker to use\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_to_root(walker: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_open_file() instead.\n Returns the inode of the current entry.\n\n\n# Arguments\n-   walker  The walker to use\n-      err     Pointer to an int where the error code will be\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_tree_walker_open_file(
        walker: *const SqshTreeWalker,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[must_use]
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_open_file() instead.\n\n Resolve a path with the tree walker.\n\n This function will resolve the given path with the tree walker. The base is\n the current directory.\n\n# Arguments\n-   walker           The walker to use\n-       path             The path to resolve.\n-       follow_symlinks  Whether to follow symlinks.\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_tree_walker_resolve(
        walker: *mut SqshTreeWalker,
        path: *const ::core::ffi::c_char,
        follow_symlinks: bool,
    ) -> ::core::ffi::c_int;
    #[deprecated]
    #[doc = " Since 1.2.0. Use sqsh_path_resolver_free() instead.\n Cleans up resources used by a SqshTreeWalker struct.\n\n\n# Arguments\n- reader The file reader struct to clean up.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_walker_free(reader: *mut SqshTreeWalker) -> ::core::ffi::c_int;
    #[doc = " Creates a new SqshTreeTraversal object rooted at the specified inode.\n\n\n The returned traversal iterator object borrows the passed file object.\n The returned traversal iterator object will visit all entries recursively\n located below the passed inode (which can be limited with\n `sqsh_tree_traversal_set_max_depth`). If the passed inode is not a directory,\n only the passed inode itself will be visited.\n\n# Arguments\n-   file     the base inode to start from.\n-  err      Pointer to an int where the error code will be\n stored.\n\n# Returns\n a new tree traversal object."]
    pub fn sqsh_tree_traversal_new(
        file: *const SqshFile,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshTreeTraversal;
    #[doc = " Sets the maximum depth of the traversal.\n\n\n# Arguments\n-   traversal  The traversal to use\n-   max_depth  The maximum depth to traverse."]
    pub fn sqsh_tree_traversal_set_max_depth(traversal: *mut SqshTreeTraversal, max_depth: usize);
    #[must_use]
    #[doc = "\n Moves the traversal to the next entry int the current directory.\n\n# Arguments\n-   traversal  The traversal to use\n-      err Pointer to an int where the error code will be stored.\n\n# Returns\n true if the traversal was moved to the next entry, false if the\n     traversal has no more entries to move to or an error occurred."]
    pub fn sqsh_tree_traversal_next(
        traversal: *mut SqshTreeTraversal,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[doc = " Returns the inode type of the current entry.\n\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n the inode type of the current entry."]
    pub fn sqsh_tree_traversal_type(traversal: *const SqshTreeTraversal) -> SqshFileType;
    #[doc = "\n returns the state of the traversal.\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n The current state of the traversal."]
    pub fn sqsh_tree_traversal_state(traversal: *const SqshTreeTraversal)
        -> SqshTreeTraversalState;
    #[doc = "\n Returns the name of the current entry.\n\n This entry is not zero terminated. The function will return an empty string\n for the uppermost object.\n\n# Arguments\n-   traversal  The traversal to use\n-  len        Pointer to a size_t where the length of the name will\n be stored.\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_tree_traversal_name(
        traversal: *const SqshTreeTraversal,
        len: *mut usize,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Creates a heap allocated copy of the path to the current entry\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n a newly heap allocated string containing the path to the current\n         entry"]
    pub fn sqsh_tree_traversal_path_dup(
        traversal: *const SqshTreeTraversal,
    ) -> *mut ::core::ffi::c_char;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the name of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n the name of the current entry."]
    pub fn sqsh_tree_traversal_name_dup(
        traversal: *const SqshTreeTraversal,
    ) -> *mut ::core::ffi::c_char;
    #[doc = " Returns the path segment at a given index.\n\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_tree_traversal_depth(traversal: *const SqshTreeTraversal) -> usize;
    #[doc = " Get a segment of the path of the current entry.\n\n\n A path segment is a part of the path that is separated by a path separator\n (`/`). The segments are indexed starting at 0, and there are `depth`\n segments in total (0 <= index < depth). The last segment is the name of the\n current entry.\n\n The root of the traversal is considered at depth 0, and so has no path\n segments (or name).\n\n If the traversal is rooted at `/a/b`, and the traversal iterator is\n pointing at `/a/b/c/d.txt`, the path segments will be [`c`, `d.txt`].\n\n The returned pointer is not zero terminated.\n\n# Arguments\n-   traversal  The traversal to use\n-      len        Pointer to a size_t where the length of the name\n will be stored.\n-       index      The index of the path segment.\n\n# Returns\n the inode of the current entry."]
    pub fn sqsh_tree_traversal_path_segment(
        traversal: *const SqshTreeTraversal,
        len: *mut usize,
        index: sqsh_index_t,
    ) -> *const ::core::ffi::c_char;
    #[doc = " Gets the underlying directory iterator pointing to the current entry.\n\n# Arguments\n-   traversal  The traversal to use\n\n# Returns\n The directory iterator pointing to the current entry, iterating the\n   parent directory, or NULL if the traversal is at its root entry"]
    pub fn sqsh_tree_traversal_iterator(
        traversal: *const SqshTreeTraversal,
    ) -> *const SqshDirectoryIterator;
    #[must_use]
    #[doc = " Returns the inode of the current entry.\n\n\n# Arguments\n-   traversal  The traversal to use\n-      err     Pointer to an int where the error code will be\n\n# Returns\n a newly allocated SqshFile for the current entry."]
    pub fn sqsh_tree_traversal_open_file(
        traversal: *const SqshTreeTraversal,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshFile;
    #[doc = "\n\n# Arguments\n- traversal The file traversal struct to clean up.\n\n# Returns\n 0 on success, less than 0 on error."]
    pub fn sqsh_tree_traversal_free(traversal: *mut SqshTreeTraversal) -> ::core::ffi::c_int;
    #[doc = " Get the version of the currently running library as a string.\n\n# Returns\n Version string"]
    pub fn sqsh_version() -> *const ::core::ffi::c_char;
    #[doc = " Get the major version of the currently running library.\n\n# Returns\n Major version"]
    pub fn sqsh_version_major() -> u16;
    #[doc = " Get the minor version of the currently running library.\n\n# Returns\n Minor version"]
    pub fn sqsh_version_minor() -> u16;
    #[doc = " Get the patch version of the currently running library.\n\n# Returns\n Patch version"]
    pub fn sqsh_version_patch() -> u16;
    #[must_use]
    #[doc = "\n Allocates and initializes a new xattr iterator.\n\n# Arguments\n-  file   The file context to iterate through xattrs.\n- err    Pointer to an int where the error code will be stored.\n\n# Returns\n The new iterator on success, NULL on error."]
    pub fn sqsh_xattr_iterator_new(
        file: *const SqshFile,
        err: *mut ::core::ffi::c_int,
    ) -> *mut SqshXattrIterator;
    #[must_use]
    #[doc = "\n Advances the iterator to the next xattr.\n\n# Arguments\n- iterator The iterator to advance.\n-    err      Pointer to an int where the error code will be\n stored.\n\n# Returns\n- true  When the iterator was advanced.\n- false When the end of the xattrs list was reached or an error\n occured."]
    pub fn sqsh_xattr_iterator_next(
        iterator: *mut SqshXattrIterator,
        err: *mut ::core::ffi::c_int,
    ) -> bool;
    #[doc = "\n Retrieves the type of the current xattr.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The type of the current xattr."]
    pub fn sqsh_xattr_iterator_type(iterator: *const SqshXattrIterator) -> u16;
    #[doc = "\n Checks if the current xattr is indirect.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n true if the xattr is indirect, false otherwise."]
    pub fn sqsh_xattr_iterator_is_indirect(iterator: *const SqshXattrIterator) -> bool;
    #[doc = "\n Retrieves the prefix of the current xattr.\n\n There are three possible prefixes that can be returned:\n\n - \"user.\"\n - \"trusted.\"\n - \"security.\"\n\n The returned pointer is staticly allocated and must not be freed.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The null terminated prefix of the current xattr. The returned pointer\n is staticly allocated and must not be freed."]
    pub fn sqsh_xattr_iterator_prefix(
        iterator: *const SqshXattrIterator,
    ) -> *const ::core::ffi::c_char;
    #[doc = "\n Retrieves the size of the prefix of the current xattr.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The size of the prefix of the current xattr."]
    pub fn sqsh_xattr_iterator_prefix_size(iterator: *const SqshXattrIterator) -> u16;
    #[doc = "\n Retrieves the name of the current xattr excluding the prefix.\n\n The returned pointer is allocated internally and only valid until the next\n call to sqsh_xattr_iterator_next(). It must not be freed. The string is not 0\n terminated. Use sqsh_xattr_iterator_name_size() to get the size of the name.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The name of the current xattr."]
    pub fn sqsh_xattr_iterator_name(
        iterator: *const SqshXattrIterator,
    ) -> *const ::core::ffi::c_char;
    #[doc = "\n Retrieves the size of the name of the current xattr.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The size of the name of the current xattr."]
    pub fn sqsh_xattr_iterator_name_size(iterator: *const SqshXattrIterator) -> u16;
    #[must_use]
    #[doc = "\n Looks up an xattr by name.\n\n# Arguments\n- iterator The iterator to use.\n- name     The name to lookup\n\n# Returns\n 0 if the xattr was found, a negative value otherwise."]
    pub fn sqsh_xattr_iterator_lookup(
        iterator: *mut SqshXattrIterator,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n Compares the full name of the current xattr with a given 0-terminated\n name.\n\n# Arguments\n- iterator The iterator to use.\n- name     The name to compare with.\n\n# Returns\n 0 if the names match, a negative value if the current xattr's name\n         is less than the given name, a positive value if the current xattr's\n         name is greater than the given name."]
    pub fn sqsh_xattr_iterator_fullname_cmp(
        iterator: *const SqshXattrIterator,
        name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the full name of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n# Arguments\n-  iterator        The iterator to use.\n\n# Returns\n The full name of the current xattr on success, NULL if the allocation\n fails."]
    pub fn sqsh_xattr_iterator_fullname_dup(
        iterator: *const SqshXattrIterator,
    ) -> *mut ::core::ffi::c_char;
    #[must_use]
    #[doc = "\n creates a heap allocated copy of the value of the current entry.\n\n The caller is responsible for calling free() on the returned pointer.\n\n The returned string is 0 terminated.\n\n\n# Arguments\n-  iterator    The iterator to use.\n\n# Returns\n The value of the current xattr on success, NULL if the allocation\n fails."]
    pub fn sqsh_xattr_iterator_value_dup(
        iterator: *const SqshXattrIterator,
    ) -> *mut ::core::ffi::c_char;
    #[doc = "\n Retrieves the value of the current xattr.\n\n The returned pointer is allocated internally and only valid until the next\n call to sqsh_xattr_iterator_next(). It must not be freed. The string is not 0\n terminated. Use sqsh_xattr_iterator_value_size() to get the size of the\n value.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The value of the current xattr. The returned pointer is allocated\n internally and only valid until the next call to sqsh_xattr_iterator_next().\n It must not be freed."]
    pub fn sqsh_xattr_iterator_value(
        iterator: *const SqshXattrIterator,
    ) -> *const ::core::ffi::c_char;
    #[doc = "\n Retrieves the size of the value of the current xattr.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The size of the value of the current xattr."]
    pub fn sqsh_xattr_iterator_value_size2(iterator: *const SqshXattrIterator) -> u32;
    #[deprecated]
    #[doc = "\n Retrieves the size of the value of the current xattr.\n Since 1.3.0. Use sqsh_xattr_iterator_value_size2() instead.\n\n# Arguments\n- iterator The iterator to use.\n\n# Returns\n The size of the value of the current xattr."]
    pub fn sqsh_xattr_iterator_value_size(iterator: *const SqshXattrIterator) -> u16;
    #[doc = "\n Frees the resources used by an xattr iterator.\n\n# Arguments\n- iterator The iterator to free.\n\n# Returns\n 0 on success, a negative value on error."]
    pub fn sqsh_xattr_iterator_free(iterator: *mut SqshXattrIterator) -> ::core::ffi::c_int;
}
